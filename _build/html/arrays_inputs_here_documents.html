

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Arrays, input, Here Documents &mdash; Linux shell tutorial  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/togglebutton.css" type="text/css" />
  <link rel="stylesheet" href="_static/mystnb.css" type="text/css" />
  <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_lesson.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_rtd_theme_ext_color_contrast.css" type="text/css" />
  <link rel="stylesheet" href="_static/tabs.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/togglebutton.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script src="_static/minipres.js"></script>
        <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Traps, debugging, profiling" href="traps_debugging_profiling.html" />
    <link rel="prev" title="Loops" href="loops.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Linux shell tutorial
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">PART #1. Linux shell basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="the_shell.html">Basic shell</a></li>
<li class="toctree-l1"><a class="reference internal" href="starting_commands.html">Starting out</a></li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="files_and_directories.html">Files and directories</a></li>
<li class="toctree-l1"><a class="reference internal" href="find.html">Find</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_archive_transfer.html">File archiving and transferring</a></li>
<li class="toctree-l1"><a class="reference internal" href="hotkeys.html">How to make things faster: hotkeys</a></li>
<li class="toctree-l1"><a class="reference internal" href="files_continue.html">File tools and command line utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="input_output.html">Input and output</a></li>
<li class="toctree-l1"><a class="reference internal" href="pipelines_grep.html">Pipelines and grep</a></li>
</ul>
<p class="caption"><span class="caption-text">PART #2. Linux shell scripting</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quoting_substitution_aliases.html">Quoting, substitutions, aliases</a></li>
<li class="toctree-l1"><a class="reference internal" href="variables_functions_environments.html">Variables, functions, environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="conditionals.html">Conditionals</a></li>
<li class="toctree-l1"><a class="reference internal" href="loops.html">Loops</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Arrays, input, Here Documents</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-the-input">Working with the input</a></li>
<li class="toctree-l2"><a class="reference internal" href="#here-document-placeholders">Here Document, placeholders</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="traps_debugging_profiling.html">Traps, debugging, profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel_crontab_perlawksed.html">Parallel, crontab, perl/awk/sed</a></li>
</ul>
<p class="caption"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html">About us</a></li>
</ul>
<p class="caption"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="to_continue.html">To continue: course development ideas/topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="bonus_material.html">Bonus material</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Linux shell tutorial</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Arrays, input, Here Documents</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/coderefinery/content/blob/main/content/arrays_inputs_here_documents.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="arrays-input-here-documents">
<h1>Arrays, input, Here Documents<a class="headerlink" href="#arrays-input-here-documents" title="Permalink to this headline">¶</a></h1>
<div class="section" id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h2>
<p>BASH supports both indexed and associative one-dimensional arrays. Indexed array can be declared
with <code class="docutils literal notranslate"><span class="pre">declare</span> <span class="pre">-a</span> <span class="pre">array_name</span></code>, or first assignment does it automatically (note: indexed arrays only):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span><span class="o">=</span><span class="p">(</span><span class="n">my</span> <span class="n">very</span> <span class="n">first</span> <span class="n">array</span><span class="p">)</span>
<span class="n">arr</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Otakaari 1&#39;</span> <span class="n">Espoo</span> <span class="mi">02150</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;PL 11000&#39;</span><span class="p">)</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">AALTO</span>
</pre></div>
</div>
<p>To access array elements (the curly braces are required, unlike normal
variable expansion):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># elements one by one
echo ${arr[0]} ${arr[1]}

# array values at once
${arr[@]}

# indexes at once
${!arr[@]}

# number of elements in the array
${#arr[@]}

# length of the element number 2
${#arr[2]}

# to append elements to the end of the array
arr+=(value)

# assign a command output to array
arr=($(command))

# emptying array
arr=()

# to destroy, delete an array
unset arr

# to unset a single array element
unset arr[6]

# sorting array
IFS=$&#39;\n&#39; sorted=($(sort &lt;&lt;&lt;&quot;${arr[*]}&quot;))

# array element inside arithmetic expanssion requires no ${}
((arr[$i]++))

# split a string like &#39;one two three etc&#39; or &#39;one,two,three,etc&#39; to an array
# note that IFS=&#39;, &#39; means that separator is either space or comma, not a sequence of them
IFS=&#39;, &#39; read -r -a arr &lt;&lt;&lt; &quot;$string&quot;

# spliting a word to an array letter by letter
word=qwerty; arr=($(echo $word | grep -o .))
</pre></div>
</div>
<p>Loops through the indexed array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>for i in ${!arr[@]}; do
  echo arr[$i] is ${arr[$i]}
done
</pre></div>
</div>
<p>Negative index counts back from the end of the array, <em>[-1]</em> referencing to the last element.</p>
<p>Quick ways to print array with no loop:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># with keys, as is
declare -p arr

# indexes -- values
echo ${!arr[@]} -- ${arr[@]}

# array elements values one per line
printf &quot;%s\n&quot; &quot;${arr[@]}&quot;
</pre></div>
</div>
<p>Passing an array to a function as an argument could be the use case when you want to make it local:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>f() {
  local arr=(${!1})    # pass $1 argument as a refence
  # do something to array elements
  echo ${arr[@]}
}

# invoke the function, huom that no changes have been done to the original arr[@]
arr=(....)
f arr[@]
</pre></div>
</div>
<p>BASH associative arrays (this type of array supported in BASH since version 4.2) needs to be
declared first (!) <code class="docutils literal notranslate"><span class="pre">declare</span> <span class="pre">-A</span> <span class="pre">asarr</span></code>.</p>
<p>Both indexed arrays and associative can be declared as an array of integers, if all elements
values are integers <code class="docutils literal notranslate"><span class="pre">declare</span> <span class="pre">-ia</span> <span class="pre">array</span></code> or <code class="docutils literal notranslate"><span class="pre">declare</span> <span class="pre">-iA</span></code>. This way element values are
treated as integers always.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asarr</span><span class="o">=</span><span class="p">([</span><span class="n">university</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;Aalto University&#39;</span> <span class="p">[</span><span class="n">city</span><span class="p">]</span><span class="o">=</span><span class="n">Espoo</span> <span class="p">[</span><span class="s1">&#39;street address&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;Otakaari 1&#39;</span><span class="p">)</span>
<span class="n">asarr</span><span class="p">[</span><span class="n">post_index</span><span class="p">]</span><span class="o">=</span><span class="mi">02150</span>
</pre></div>
</div>
<p>Addressing is similar to indexed arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>for i in &quot;${!asarr[@]}&quot;; do
  echo asarr[$i] is ${asarr[$i]}
done
</pre></div>
</div>
<p>Even though key can have spaces in it, quoting can be omitted.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># use case: your command returns list of lines like: &#39;string1 string2&#39;
# adding them to an assoative array like: [string1]=string2
declare -A arr
for i in $(command); do
  arr+=([&quot;${i/ */}&quot;]=&quot;${i/* /}&quot;)
done
</pre></div>
</div>
<p>Variable expanssions come out in the new light:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># this will return two elements of the array starting from number 1
${arr[@]:1:2}

# all elements without last one
${arr[@]:0:${#arr[@]}-1}

# parts replacement will be applied to all array elements
declare -A emails=([Vesa]=vesa@aalto.fi [Kimmo]=kimmo@helsinki.fi [Anna]=anna@math.tut.fi)
echo ${emails[@]/@*/@gmail.com}
# returns: vesa@gmail.com anna@gmail.com kimmo@gmail.com
</pre></div>
</div>
<p>For a sake of demo: let us count unique users and their occurances (yes, one can do it with ‘uniq -c’ :)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># declare assoative array of integers
declare -iA arr

for i in $(w -h | cut -c1-8); do   # get list of currenly logged users into loop
  for u in ${!arr[@]}; do   # check that they are unique
    if [[ $i == $u ]]; then
      ((arr[$i]++))
      continue 2
    fi
  done
  arr[$i]=1  # if new, add a new array element
done

for j in ${!arr[@]}; do    # printing out
  echo ${arr[$j]} $j
done
</pre></div>
</div>
<p>Another working demo: script that automates backups or just makes a sync of data to a remote server.
Same can be adapted to copy locally, to a usb drive or alike.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># array of directories to be backuped, to skip one, just comment with #
declare -A dirs
dirs[wlocal]=/l/$USER
dirs[xpproject]=/m/phys/extra/project/xp
dirs[homebin]=$HOME/bin

cmd=&#39;/usr/bin/rsync&#39;                   # rsync
args=&quot;-auvW --delete --progress $@&quot;    # accept extra args, like &#39;-n&#39; for the dryrun first
serv=&#39;user@server:backups&#39;             # copying to ~/backups that must exist

# array key is used for the remote dir name
for d in ${!dirs[@]}; do
  echo &quot;Syncing ${dirs[$d]}...&quot;
  $cmd $args ${dirs[$d]}/ $serv/$d
done
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Exercise 2.5</dt>
<dd class="field-odd"><ul class="simple">
<li><p>make a script/function that produces an array of random numbers, make sure that numbers
are unique. Print the array nicely using <code class="docutils literal notranslate"><span class="pre">printf</span></code> for formating.</p>
<ul>
<li><p>one version should use BASH functionality only (Tip: <code class="docutils literal notranslate"><span class="pre">$RANDOM</span></code>)</p></li>
<li><p>the other one can use <code class="docutils literal notranslate"><span class="pre">shuf</span></code></p></li>
</ul>
</li>
<li><p>(*) Pick up the <code class="docutils literal notranslate"><span class="pre">ipvalid</span></code> function that we have developed earlier, implement IP matching
regular expression as <code class="docutils literal notranslate"><span class="pre">^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$</span></code> and
work with the ${BASH_REMATCH[*]} array to make sure that all numbers are in the range 0-255</p></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="working-with-the-input">
<h2>Working with the input<a class="headerlink" href="#working-with-the-input" title="Permalink to this headline">¶</a></h2>
<p>User input can be given to a script in three ways:</p>
<blockquote>
<div><ul class="simple">
<li><p>as command arguments, like <code class="docutils literal notranslate"><span class="pre">./script.sh</span> <span class="pre">arg1</span> <span class="pre">arg2</span> <span class="pre">...</span></code></p></li>
<li><p>interactively from keyboard with <code class="docutils literal notranslate"><span class="pre">read</span></code> command</p></li>
<li><p>as standard input, like <code class="docutils literal notranslate"><span class="pre">command</span> <span class="pre">|</span> <span class="pre">./script</span></code></p></li>
</ul>
</div></blockquote>
<p>Nothing stops from using a combination of them or all of the approaches in one script.
Let us go through the last two first and then get back to command line arguments.</p>
<p><code class="docutils literal notranslate"><span class="pre">read</span></code> can do both: read from keyboard or from STDIN</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># the command prints the prompt, waits for the response, and then assigns it</span>
<span class="c1"># to variable(s)</span>
<span class="n">read</span> <span class="o">-</span><span class="n">p</span> <span class="s1">&#39;Your names: &#39;</span> <span class="n">firstn</span> <span class="n">lastn</span>

<span class="c1"># read into array, each word as a new array element (&#39;arr&#39; declared automatically)</span>
<span class="n">read</span> <span class="o">-</span><span class="n">a</span> <span class="n">arr</span> <span class="o">-</span><span class="n">p</span> <span class="s1">&#39;Your names: &#39;</span>
</pre></div>
</div>
<p>Given input must be checked (!) with a pattern, especially if script creates directories,
removes files, sends emails based on the input.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># request a new directory name till correct one is given (interrupt with Ctrl-C)
regexp=&#39;^[a-zA-Z0-9/_-]+$&#39;
until [[ &quot;$newdir&quot; =~ $regexp ]]; do
  read -p &#39;New directory: &#39; newdir
done
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">read</span></code> selected options</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-a</span> <span class="pre">&lt;ARRAY&gt;</span></code>  read the data word-wise into the specified array &lt;ARRAY&gt; instead of normal variables</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-N</span> <span class="pre">&lt;NCHARS&gt;</span></code> reads &lt;NCHARS&gt; characters of input, ignoring any delimiter, then quits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">&lt;PROMPT&gt;</span></code> the prompt string &lt;PROMPT&gt; is output (without a trailing automatic newline) before the read is performed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-r</span></code>  raw input - disables interpretion of backslash escapes and line-continuation in the read data</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-s</span></code> secure input - don’t echo input if on a terminal (passwords!)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">&lt;TIMEOUT&gt;</span></code> wait for data &lt;TIMEOUT&gt; seconds, then quit (exit code 1)</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">read</span></code> is capable of reading STDIN, case like <code class="docutils literal notranslate"><span class="pre">command</span> <span class="pre">|</span> <span class="pre">./script</span></code>, with <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">read</span> <span class="pre">var</span></code> it goes
through the input line by line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># IFS= is empty and echo argument in quotes to make sure we keep the format</span>
<span class="c1"># otherwise all spaces and new lines shrinked to one and leading/trailing whitespace trimmed</span>
<span class="k">while</span> <span class="n">IFS</span><span class="o">=</span> <span class="n">read</span> <span class="o">-</span><span class="n">r</span> <span class="n">line</span><span class="p">;</span> <span class="n">do</span>
  <span class="n">echo</span> <span class="s2">&quot;line is $line&quot;</span>    <span class="c1"># do something useful with $line</span>
<span class="n">done</span>

<span class="c1"># To check current $IFS</span>
<span class="n">cat</span> <span class="o">-</span><span class="n">A</span> <span class="o">&lt;&lt;&lt;</span><span class="s2">&quot;$IFS&quot;</span>
</pre></div>
</div>
<p>Though in general, whatever comes from STDIN can be proceeded as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># to check that STDIN is not empty</span>
<span class="k">if</span> <span class="p">[[</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">stdin</span> <span class="p">]];</span> <span class="n">then</span>
  <span class="c1"># passing STDIN to a pipeline  (/dev/stdin can be omitted)</span>
  <span class="n">cat</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">stdin</span> <span class="o">|</span> <span class="n">cut</span> <span class="o">-</span><span class="n">d</span><span class="s1">&#39; &#39;</span> <span class="o">-</span><span class="n">f</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span> <span class="o">|</span> <span class="n">sort</span>
<span class="n">fi</span>
</pre></div>
</div>
<p>Other STDIN tricks that one can use in the scripts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># to read STDIN to a variable, both commands do the same
var=$(&lt;/dev/stdin)
var=$(cat)
</pre></div>
</div>
<p>In the simplest cases like <code class="docutils literal notranslate"><span class="pre">./script</span> <span class="pre">arg1</span> <span class="pre">arg2</span> <span class="pre">...</span></code>, you check <em>$#</em> and then assign
<em>$1, $2, …</em> the way your script requires.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># here we require exactly two arguments
if (($#==2)); then
  var1=$1 var2=$2
  # ... do something useful
else
  echo &#39;Wrong amount of arguments&#39;
  echo &quot;Usage: ${0##*/} arg1 arg2&quot;
  exit 1
fi
</pre></div>
</div>
<p>To work with all input arguments at once we have <em>$&#64;</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># $# is a number of arguments on the command line, must be non-zero
if (($#)); then
  for i; do
    echo &quot;$i&quot;
    # ... do something useful with each element of $@
    # note that &#39;for ...&#39; uses $@ by default if no other list given with &#39;in ...&#39;
  done
else
  echo &#39;No command line arguments given&#39;
fi
</pre></div>
</div>
<p>As a use case, our <em>tarit.sh</em> script. The script can accept STDIN and
arguments, so we check both:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Usage: tarit.sh [dirname1 [dirname2 [dirname3 ...]]]
# or     command | tarit.sh

# by default no directories to archive. i.e. current
args=&#39;&#39;

# checking for STDIN, if any, assigning STDIN to $args
[[ -p /dev/stdin ]] &amp;&amp; args=$(&lt;/dev/stdin)

# if arguments are given, appending the $args with $@
(($#)) &amp;&amp; args+=&quot; $@&quot;

# no arguments, no stdin, then it is a current dir
[[ -z &quot;$args&quot; ]] &amp;&amp; args=&quot;$(pwd)&quot;

# by now we should have a directory list in $args to archive
for d in $args; do
  # checking that directory exists, if so, archive it
  if [[ -d &quot;$d&quot; ]]; then
    echo Archiving $d ...
    tar caf ${d##*/}.$(date +%Y-%m-%d).tar.gz &quot;$d&quot;
  else
    echo &quot;   $d does not exist, skipping.&quot;
  fi
done
</pre></div>
</div>
<p>Often, the above mentioned ways are more than enough for simple scripts.
But what if options and arguments are like
<code class="docutils literal notranslate"><span class="pre">./script</span> <span class="pre">[-f</span> <span class="pre">filename]</span> <span class="pre">[-z]</span> <span class="pre">[-b]</span> <span class="pre">[arg1</span> <span class="pre">[arg2</span> <span class="pre">[...]]]</span></code> or more complex?
(common notaion: options in the square brackets are optional). What if you write
a production ready script that will be used by many other as well?</p>
<p>It is were <code class="docutils literal notranslate"><span class="pre">getopt</span></code> offers a more efficient way of handling script’s input options.
In the simplest case <code class="docutils literal notranslate"><span class="pre">getopt</span></code> command (do not get confused with <code class="docutils literal notranslate"><span class="pre">getopts</span></code> built-in BASH
function of similar kind) requires two parameters to work:
first is a list of valid input options – sequence of letters and colons. If letter
followed by a colon, the option requires an argument, if folowed by two colons, argument
is optional. For example, the string <code class="docutils literal notranslate"><span class="pre">getopt</span> <span class="pre">&quot;sdf:&quot;</span></code> says that the options -s, -d and -f
are valid and -f requires an argument, like <em>-f filename</em>.
The second argument required by  <em>getopt</em> is a list of input parameters (options + arguments)
to check, i.e. just <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code>.</p>
<p>Let us use <em>cx</em> script as a demo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># common usage function with the exit at the end
usage() {
  echo &quot;Usage: $sname [options] file [file [file...]]&quot;
  echo &#39;       -a, gives access to all, like a+x, by default +x&#39;
  echo &#39;       -d &lt;directory/path/bin&gt;, path to the bin directory&#39;
  echo &quot;          can be used in &#39;cx&#39; to copy a new script there&quot;
  echo &#39;       -a, gives access to all, like a+x, by default +x&#39;
  echo &#39;       -d &lt;directory/path/bin&gt;, path to the bin directory&#39;
  echo &quot;          can be used in &#39;cx&#39; to copy a new script there&quot;
  echo &#39;       -v, verbose mode for chmod&#39;
  echo &#39;       -h, this help message&#39;
  exit 1
}

# whole trick is in this part: getopt validates the input parameters,
# structures them by dividing options and arguments with --,
# and returns them to a variable
# then they are reassigned back to $@ with &#39;set --&#39;
opts=$(getopt &quot;avhd:&quot; &quot;$@&quot;) || usage
set -- $opts

# defining variables&#39; default values
ALL=&#39;&#39;
CMD=&#39;/usr/bin/chmod&#39;
sname=${0##*/}  # the name this script was called by

# by now we have a well structured $@ which we can trust.
# to go through options one by one we start an endless &#39;while&#39; loop
# with the nested &#39;case&#39;. &#39;shift&#39; makes another trick, every time
# it is invoked it is equal to &#39;unset $1&#39;, thus $@ arguments are
# &quot;shifted down&quot;, $2 becomes $1, $3 becomes $2, etc
# &#39;getopt&#39; adds -- to $@ which separates valid options and the rest
# that did not qualify, when it comes to &#39;--&#39; we &#39;break&#39; the loop
while true; do
  case ${1} in
    -h) usage ;; # output help message and exit
    -a) ALL=a ;; # if -a is given we set ALL
    -v) CMD+=&#39; -v&#39; ;; # if verbose mode required
    -d) shift # shift to take next item as a directory path for -d
        BINDIR=&quot;$1&quot;
        if [[ -z &quot;$BINDIR&quot; || ! -d &quot;$BINDIR&quot; ]]; then
          echo &quot;ERROR: the directory does not exist&quot;
          usage
        fi
     ;;
    --) shift; break ;;   # remove --
  esac
  shift
done

# script body

case &quot;$sname&quot; in
  cx*) $CMD ${ALL}+rx &quot;$@&quot; &amp;&amp; \
       [[ -n &quot;$BINDIR&quot; ]] &amp;&amp; cp -p $@ $BINDIR ;;
  cw*) $CMD ${ALL}+w &quot;$@&quot; ;;
  cr*) $CMD ${ALL}+r &quot;$@&quot; ;;
  c-w*) $CMD ${ALL}-w &quot;$@&quot; ;;
  *) echo &quot;ERROR: no idea what $sname is supposed to do&quot;; exit 1 ;;
esac
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">getopt</span></code> can do way more, go for <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">getopt</span></code> for details, as an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># here is getopt sets name with &#39;-n&#39; used while reporting errors: our script name
# accepts long options like &#39;--filename myfile&#39; along with &#39;-f myfile&#39;
getopt -n $(basename $0)  -o &quot;hac::f:&quot; --long &quot;help,filename:,compress::&quot;  -- &quot;$@&quot;
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Exercise 2.6</dt>
<dd class="field-odd"><ul>
<li><p>Using the latest <em>tarit.sh</em> (see lecture notes) version as an example,
expand above <em>cx</em> script to
accept STDIN, like <code class="docutils literal notranslate"><span class="pre">command</span> <span class="pre">|</span> <span class="pre">cx</span> <span class="pre">[options]</span></code>, where <code class="docutils literal notranslate"><span class="pre">command</span></code> produces a list of
files. Example <code class="docutils literal notranslate"><span class="pre">find</span> <span class="pre">.</span> <span class="pre">-t</span> <span class="pre">file</span> <span class="pre">-name</span> <span class="pre">'*.sh'</span> <span class="pre">|</span> <span class="pre">cx</span> <span class="pre">-a</span> <span class="pre">-d</span> <span class="pre">/path/to/bin</span></code>.</p></li>
<li><p>Using <em>cx</em> demo as an example, expand the latest version of our <em>tarit.sh</em>
(see lecture notes) to make it accepting the following options and arguments:
<code class="docutils literal notranslate"><span class="pre">tarit.sh</span> <span class="pre">-h</span> <span class="pre">-y</span> <span class="pre">-d</span> <span class="pre">&lt;directory/with/backups&gt;</span> <span class="pre">[dirname1</span> <span class="pre">[dirname2</span> <span class="pre">[dirname3</span> <span class="pre">...]]]</span></code>.
By default, with no args, it still should make an archive of the current directory.
<code class="docutils literal notranslate"><span class="pre">-h</span></code> returns usage info, <code class="docutils literal notranslate"><span class="pre">-d</span> <span class="pre">&lt;directory/path/with/backups&gt;</span></code> is a directory the
tar archives will go to, your script has to check that directory exists, the
script must also check whether a newly created archive already exist and if so, skip
creating the archive with the corresponding warning message.</p>
<blockquote>
<div><ul class="simple">
<li><p>(*) <code class="docutils literal notranslate"><span class="pre">-y</span></code> should force overwriting already existing archive.</p></li>
<li><p>(*) <code class="docutils literal notranslate"><span class="pre">-s</span></code> should make script silent, so that no errors or other messages
would come from any inline command.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="here-document-placeholders">
<h2>Here Document, placeholders<a class="headerlink" href="#here-document-placeholders" title="Permalink to this headline">¶</a></h2>
<p>A ‘here document’ and ‘here string’ take the line(s) following and send them to standard
input. It’s a way to send larger blocks to stdin.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># instead of &#39;echo $STRING | command ...&#39;
command &lt;&lt;&lt;$STRING

# instead of &#39;cat file | command ...&#39;
command &lt;&lt;SomeMagicStopWord
The benefit is that one can use $var, $() etc in the text
The text ends with the Stop Word on a new line, the word can be any
SomeMagicStopWord
</pre></div>
</div>
<p>Often used for messaging, be it an email or dumping bunch of text to file.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># NAME, SURNAME, EMAIL, DAYS are set earlier

mail -s &#39;Account expiration&#39; $EMAIL&lt;&lt;END-OF-EMAIL
Dear $NAME $SURNAME,

your account is about to expire in $DAYS days.

$(date)

Best Regards,
Aalto ITS
END-OF-EMAIL
</pre></div>
</div>
<p>Or just outputting to a file (same can be done with echo commands):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cat</span> <span class="o">&lt;&lt;</span><span class="n">EOF</span> <span class="o">&gt;</span><span class="n">filename</span>
<span class="o">...</span> <span class="n">text</span>
<span class="n">EOF</span>
</pre></div>
</div>
<p>One trick that is particularly useful is using this to make a long
comment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">:</span> <span class="o">&lt;&lt;</span>\<span class="n">COMMENTS</span>
<span class="n">here</span> <span class="n">come</span> <span class="n">text</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">seen</span> <span class="n">nowhere</span>
<span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">comment</span> <span class="n">every</span> <span class="n">single</span> <span class="n">line</span> <span class="k">with</span> <span class="c1">#</span>
<span class="n">COMMENTS</span>
</pre></div>
</div>
<p><strong>Hint</strong> <code class="docutils literal notranslate"><span class="pre">&lt;&lt;\LimtiString</span></code> to turn off substitutions and place text as is with $ marks etc</p>
<p>In case you have a template file which contains variables as placeholders, replacing them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># &#39;template&#39; file like:
The name is $NAME, the email is $EMAIL

# command to substitute the placeholders and redirect to &#39;output&#39; file
# the original &#39;template&#39; file remains as is
NAME=Jussi EMAIL=jussi@gmail.com
cat template | while IFS= read -r line; do eval echo $line; done &gt; output
# resulting file: The name is Jussi, the email is jussi@gmail.com
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="traps_debugging_profiling.html" class="btn btn-neutral float-right" title="Traps, debugging, profiling" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="loops.html" class="btn btn-neutral float-left" title="Loops" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Aalto Science-IT.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>